<html>

<head>
  <!-- This is used to fix some scaling bugs -->
  <!-- Was seen in one of the examples -->
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  <title>Practical assignment 4</title>
  <style>
      body {
          margin: 0;
      }

      canvas {
          display: block;
      }

      .floating-bar {
          position: absolute;
          width: 250
      }

      .field .header {
          margin-bottom: 5;
          font-size: 13px;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
          color: white;
          display: inline-block;
      }

      .field {
          background-color: #171d22;
          border-radius: 5px;
          padding: 10px;
          margin: 25px;
      }

      .field input {
          width: 98%;
      }

      .field select {
          width: 100%;
      }

      .field button {
          width: 100%
      }
  </style>
  <script src="https://kormax.github.io/scripts/ar/three.min.js"></script>
  <script src="https://kormax.github.io/scripts/ar/ar.js"></script>
</head>

<body style="margin : 0; overflow: hidden; font-family: Monospace,serif;">
<script>
    const C = 1;

    const renderer = new THREE.WebGLRenderer({alpha: true});
    document.body.appendChild(renderer.domElement);


    const scene = new THREE.Scene();
    const camera = new THREE.Camera();

    scene.add(camera);

    const arToolkitSource = new THREEx.ArToolkitSource({
        sourceType: 'webcam',
        displayWidth: window.innerWidth,
        displayHeight: window.innerHeight
    });
    arToolkitSource.init(() => {
        resize()
    })


    const arToolkitContext = new THREEx.ArToolkitContext({
        cameraParametersUrl: 'https://alexveretrnkin.github.io/parameters.dat',
        detectionMode: 'mono',
        maxDetectionRate: 60,					// 60 times per second
        canvasWidth: window.innerWidth,
        canvasHeight: window.innerHeight
    })
    arToolkitContext.init(() => {
        camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
    });

    const fiFunc = (u) => {
        return -(u / Math.sqrt(C + 1)) + Math.atan(Math.sqrt(C + 1) * Math.tan(u))
    };

    const aFunc = (u, v) => {
        return 2 / (C + 1 - C * Math.sin(v) ** 2 * Math.cos(u) ** 2);
    };

    const rFunc = (u, v) => {
        return (aFunc(u, v) / Math.sqrt(C)) * (Math.sqrt((C + 1) * (1 + C * Math.sin(u) * Math.sin(u))) * Math.sin(v));
    };

    const eps = 0.0000001
    const sivertSurface = (u, v, vector) => {
        // (0.5 - u) * eps this need to match condition -Pi / 2 < u < Pi / 2
        let calculatedU = u * Math.PI - Math.PI / 2 + (0.5 - u) * eps;
        let calculatedV = v * Math.PI + (0.5 - v) * eps;

        vector.x = rFunc(calculatedU, calculatedV) * Math.cos(fiFunc(calculatedU));

        vector.y = rFunc(calculatedU, calculatedV) * Math.sin(fiFunc(calculatedU));

        vector.z = (Math.log(Math.tan(calculatedV / 2)) + aFunc(calculatedU, calculatedV) * (C + 1) * Math.cos(calculatedV)) / Math.sqrt(C);
    };

    let geometry = new THREE.ParametricGeometry(sivertSurface, 50, 50);

    let markerRoot = new THREE.Group();
    scene.add(markerRoot);
    let markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
        type: 'pattern',patternUrl: "https://alexveretrnkin.github.io/apple.patt",
    });
    let object = createObject();
    object.position.y = 0.75;
    markerRoot.add(object);


    function animate(currentMs) {
        requestAnimationFrame(animate);
        if (arToolkitSource.ready) {
            arToolkitContext.update(arToolkitSource.domElement);
        }
        renderer.render(scene, camera);
    }

    function resize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
        arToolkitSource.onResizeElement()
        arToolkitSource.copyElementSizeTo(renderer.domElement)
        if (arToolkitContext.arController !== null) {
            arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas)
        }
    }

    function createObject(materialName) {
        // Multiply by 1 to try convert it to a number if it is not.
        let wireframe = new THREE.WireframeGeometry(geometry);
        material = new THREE.LineBasicMaterial({
            color: 0x008f11,
            linewidth: 2,
            side: THREE.FrontSide,
            transparent: true, // Transparent
            opacity: 1,
            depthTest: true,    // This would pervent issues if more than one object is drawn,
        });
        surface = new THREE.LineSegments(wireframe, material);

        return surface
    }

    window.addEventListener('resize', () => {
        resize()
    });

    resize();
    animate();

</script>
</body>
</html>
